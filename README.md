# App-Driver
a app and driver code for andoird engineer

/----------------------------------------------------/
项目简介：
	创建一个通用的debug节点创建系统，抽象各个命令的分类，
一般分为：参数控制类，开关类，函数执行类，通信类，信息类这几大类。
所有调试项被分入这几类中，上层可通过注册信息得出下层有多少调试项
参与调试，并且使用统一的调用接口来调用底层的调试项，使得调试只需
要底层修改，而上层app无需重新修改，只需获取节点和组织调试项的关系
来进行调试。(部分如i2c更具体通信方式以后添加子项)
/----------------------------------------------------/

engineer_debugs为项目名

R--Run			函数执行	
P--Parameter 	参数修改
S--Switch		开关类
T--Transform	通讯类
I--Info			信息类
---------------------------
被执行的命令类叫做调试项

device+laber+property 形式
根据device生成目录，根据laber生成文件，根据property是的上层生成相应控件

R -- 主要以执行某段函数代码为主
P -- 某个要被修改的参数
S -- 某个定义为只有开与关状态的变量或者动作函数
T -- 某个通讯模块
I -- 某段信息，主要以字符串为主
------------------------------------------------------------------------------驱动层说明---------------------------------------------------------------------------------
驱动层定义如下：
debug_list my_debug_list[] = {
	{{"parame1","P(i)",&a},NULL},
	{{"parame2","P(c)",&b},NULL},
	{{"func1","R(i)",&my_func},NULL},
	{{"print_parame","R(v)",&print_parame},NULL},
	{{"sw1","S(p)",&my_swtich1},NULL},
	{{"sw2","S(f)",&my_switch2},NULL},
};
说明:这里的第一个参数是laber名，中间的代表属性，代码中的属性分配依靠改段程序，而括号则代表注明，比如S(p),S(f),p-参数性质的开关，f-函数性质的开关。
	P(i),P(c),i-表示数据中的参数是int类型的。R(i),R(v),i-运行的函数有一个int形参，v—代表void。

------------------------------------------------------------------------------------上层使用说明-------------------------------------------------------------------------------
上层使用open一次可生产本次代用的调试项列表，通过read可获取读取到所有注册的命令列表。
通过ioctl可达成以下命令：1.open或者close switch控件。2.设置Parameter控件的数值。3.运行一此Run控件，也就是执行底层设置好的一段代码

	
ioctl :控制如下命令函数执行，开关控制，参数设置。使用cmd = 指令(8位) + 调试项编号(24位) 
eg:	在列表中开关有 sw1 sw2，这样如果想要开启sw2，cmd = (EN_DEBUG_OPEN<<24) + (2)

还需增加：参数越界检测，是否为正值负用。
		函数可变参运行。
		通信模块抽象
