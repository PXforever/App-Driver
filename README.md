/----------------------------------------------------/
项目简介：
	创建一个通用的debug节点创建系统，抽象各个命令的分类，
一般分为：参数控制类，开关类，函数执行类，通信类，信息类这几大类。
所有调试项被分入这几类中，上层可通过注册信息得出下层有多少调试项
参与调试，并且使用统一的调用接口来调用底层的调试项，使得调试只需
要底层修改，而上层app无需重新修改，只需获取节点和组织调试项的关系
来进行调试。(部分如i2c更具体通信方式以后添加子项)
/----------------------------------------------------/

engineer_debugs为项目名

R--Run			函数执行	
P--Parameter 	参数修改
S--Switch		开关类
T--Transform	通讯类
I--Info			信息类
---------------------------
被执行的命令类叫做调试项

device+laber+property 形式
根据device生成目录，根据laber生成文件，根据property是的上层生成相应控件

R -- 主要以执行某段函数代码为主
P -- 某个要被修改的参数
S -- 某个定义为只有开与关状态的变量或者动作函数
T -- 某个通讯模块
I -- 某段信息，主要以字符串为主
------------------------------------------------------------------------------驱动层说明---------------------------------------------------------------------------------
驱动层定义如下：
debug_list my_debug_list[] = {
	{{"parame1","P(i)",&a},NULL},
	{{"parame2","P(c)",&b},NULL},
	{{"func1","R(i)",&my_func},NULL},
	{{"print_parame","R(v)",&print_parame},NULL},
	{{"sw1","S(p)",&my_swtich1},NULL},
	{{"sw2","S(f)",&my_switch2},NULL},
};
说明:这里的第一个参数是laber名，中间的代表属性，代码中的属性分配依靠改段程序，而括号则代表注明，比如S(p),S(f),p-参数性质的开关，f-函数性质的开关。
	P(i),P(c),i-表示数据中的参数是int类型的。R(i),R(v),i-运行的函数有一个int形参，v—代表void。

------------------------------------------------------------------------------------上层使用说明-------------------------------------------------------------------------------
使用流程：~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
1.上层使用open一次可生产本次参与的调试项列表，通过read可获取读取到所有注册的命令列表。

2.使用read函数，向下传入"option info\0"字符串即可在上层获得的info是关于所有的调试项的信息，信息组织为以下字符串：
---------------------------------横线不是内容--------------------------------------------
R=2,P=5,S=2,T=0,I=0
R<func1:R(i)|print_parame:R(v)|
P<parame1:P(i)|parame2:P(c)|parame3:P(c)|parame4:P(c)|parame5:P(c)|
S<sw1:S(p)|sw2:S(f)|
T<
I<
-----------------------------------横线不是内容-----------------------------------------
注：第一行为指示每个控件个有多少个调试项，如R=2，指的是Run类有两个控件
	第二行指的是Run的具体列表,“R”指的是Run，“P”指的是Parame...
	“<”符号一类控件的起始符号
	“:”前面试调试项名,后面是属性。
	属性中的小括号“()”指的是附加属性
	每个调试项使用“|”来分隔开

3.可使用read函数来获取状态，详细可见int get_status( char property, char *laber)示例。

4.可使用ioctl实现执行命令。
使用流程：~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

ioctl解释：~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define EN_DEBUG_OPEN		1
#define EN_DEBUG_CLOSE		2
#define EN_DEBUG_SET		3
#define EN_DEBUG_RUN		4
#define EN_DEBUG_MAX_IOCTL		EN_DEBUG_RUN
通过ioctl可达成以下命令：1.open或者close switch控件。2.设置Parameter控件的数值。3.运行一此Run控件，也就是执行底层设置好的一段代码
ioctl :控制如下命令函数执行，开关控制，参数设置。使用cmd = 指令(8位) + 调试项编号(24位) 
eg:	在列表中开关有 sw1 sw2，这样如果想要开启sw2，cmd = (EN_DEBUG_OPEN<<24) + (2)
	比如运行函数func1,由表可知func1在R链中的第1位置，故:cmd = (EN_DEBUG_RUN<<24) + (1)
	设置参数链中的第4个参数 cmd = (EN_DEBUG_SET<<24) + (4),而参数数值想设为54，则ioctl( fd, cmd, 54)
注：ioctl第三个参数在open，close，switch都是无用的，只有parame可使用来设置数值大小。
ioctl解释：~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


还需增加：参数越界检测，是否为正值负用。
		函数可变参运行。
		通信模块抽象